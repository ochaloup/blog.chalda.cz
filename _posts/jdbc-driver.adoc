For working with multiple database connections in transactionaly reliable way
you need either hacking on transaction handling (probably with knowledge of XA specification)
or use transaction manager to that for you.

If you use a transaction manager for that purpose, expecting here running a standalone application,
you need to get the transaction manager, begin transaction and enlist each resource
with the transaction for transaction manager to know which are those participants that are expected
to be finished with ACID guarantees.

If you use Narayana you have option to use the Narayana jdbc transaction driver
(https://github.com/jbosstm/narayana/blob/master/ArjunaJTA/jdbc/classes/com/arjuna/ats/jdbc/TransactionalDriver.java).
That makes your life easier as you can configure the driver to provide you a connection
which is wrapped by the transactional functionality where you don't need to care of if.

This post elaborate on ways to set up the Narayana transaction manager.

How is it when you manage the transaction enlistment on your own

```java
// here we get instance of Narayana transaction manager
TransactionManager tm = com.arjuna.ats.jta.TransactionManager.transactionManager();
// and beginning the global transaction for XAResources could be enlisted into
tm.begin();

// getting DB2 datasource which then provides XAResource
XADataSource dsXA = JdbcDataSource ds = new JdbcDataSource();
// the xa datasource has to be filled with information to connection happens, using setters
dsXA.set...();
// from XADataSource getting XAConnection and then the XAResource
XAConnection xaConn = dsXA.getXAConnection();
// transaction manager to be provided with the XAResource
tm.getTransaction().enlistResource(xaConn.getXAResource());

// the business logic in database in the transaction happening here
PreparedStatement ps = xaConn.getConnection().prepareStatement("INSERT INTO TEST values (?, ?)");
ps.setInt(1, 1);
ps.setString(2, "Narayana");

// statement executed and transaction is committed or rolled-back depending of the result
try {
  ps.executeUpdate();
  tm.commit();
} catch (Exception e) {
  tm.rollback();
}
```

How is the same task will be with the transaction driver?
We need an XADataSource to be provided to the transactional driver. Then we
are requesting connection from the transactional driver and not directly from the
XADataSource. The driver then controls the connection hand over and the resource
is automatically enlisted to an active transaction. That way you don't need to
think of getting XAConnection and XADatasource and enlisting them to the transaction
and as a bigger benefit you don't need to pass the transaction and the connection from
method to a method as parameter but you can simply use the transactional driver connection withdrawal.

There is basically three possibilities how to provide XADataSource to the transactional driver. Let's go through them.

First you can provide directly an instance of XADataSource. This single instance is used
for the further connection distribution. This settings is done with property
`TransactionalDriver.XADataSource`. That key is filled with instance of the XADataSource.

```java
// XADataSource initialized to be passed to transactional driver
XADataSource dsXA = JdbcDataSource ds = new JdbcDataSource();
dsXA.set...();
// the datasource is put as property with the special name
Properties  connProperties = new Properties();
connProperties.put(TransactionalDriver.XADataSource, dsXA);
// getting connection when the 'url' is 'jdbc:arjuna' prefix which determines the Naryana drive to be used
Connection con = DriverManager.getConnection(TransactionalDriver.arjunaDriver, connProperties);

// starting transaction
TransactionManager tm = com.arjuna.ats.jta.TransactionManager.transactionManager();
tm.begin();

// filling data to be executed later
PreparedStatement ps = conn1.prepareStatement("INSERT INTO TEST values (?, ?)");
ps.setInt(1, 41);
ps.setString(2, "Narayana");

// execution, committing/rolling-back
try {
  ps.executeUpdate();
  tm.commit();
} catch (Exception e) {
  tm.rollback();
}
```

The other possibility is using jndi to bind the XADataSource and provide the jndi
as part of the url to transactional driver.

```java
// the jndi name has to start with the Narayana transactional driver prefix,
// for would be determined that we want connection of transactional driver
// the suffix (here 'ds') is used as jndi name that XADataSource will be bound to
XADataSource dsXA = JdbcDataSource ds = new JdbcDataSource();
dsXA.set...();

// binding xa datasource to jndi name 'ds'
InitialContext ctx = new IntitialContext();
ctx.bind("ds", dsXA);

// passing the jndi name 'ds' as part of the connection url that we demand
// the first part is narayana transactional driver prefix
String dsJndi = TransactionalDriver.arjunaDriver + "ds";
Connection conn = DriverManager.getConnection(dsJndi, new Properties());

// get transaction driver and start transaction
TransactionManager tm = com.arjuna.ats.jta.TransactionManager.transactionManager();
tm.begin();

// data insertion preparation
PreparedStatement ps = conn1.prepareStatement("INSERT INTO TEST values (?, ?)");
ps.setInt(1, 42);
ps.setString(2, "Narayana");

// execute, commit or rollback
try {
  ps.executeUpdate();
  tm.commit();
} catch (Exception e) {
  tm.rollback();
}
```

The third option is use a construct of dynamic class. Here the part of the url
after the `arjunaDriver` prefix depends on implementation of interface `com.arjuna.ats.internal.jdbc.DynamicClass`.
Currently there is an only one provided `com.arjuna.ats.internal.jdbc.drivers.PropertyFileDynamicClass`.
This expects that the jdbc url contains path to the properties file. This property file than
defines a name of class implementing the XADataSource interface. This name is put under the key `xaDataSourceClassName`.
Then you need to provide connection variables (jdbc url, username, password) where each of the properties
is dynamically invoked as a setter on the particular XADataSource class.

```java
// jdbc url is defined with path to the properties file
Properties props = new Properties();
props.put(TransactionalDriver.dynamicClass, PropertyFileDynamicClass.class.getName());
Connection conn1 = DriverManager.getConnection(TransactionalDriver.arjunaDriver + "./ds.properties", props);

// starting transaction
TransactionManager tm = com.arjuna.ats.jta.TransactionManager.transactionManager();
tm.begin();

// data insertion preparation
PreparedStatement ps = conn1.prepareStatement("INSERT INTO TEST values (?, ?)");
ps.setInt(1, 43);
ps.setString(2, "Narayana");

// execute, commit or rollback
try {
  ps.executeUpdate();
  tm.commit();
} catch (Exception e) {
  tm.rollback();
}
```

and the `./ds.properties` file could look like this

```
# implementation of XADataSource
xaDataSourceClassName=org.h2.jdbcx.JdbcDataSource
# properties which will be invoked on dynamically created XADataSource as setters.
#   For example there will be call
#   JdbcDataSource.setURL("jdbc:h2:mem:test1;DB_CLOSE_DELAY=-1")
URL=jdbc:h2:mem:test1;DB_CLOSE_DELAY=-1
User=
Password=
```

Let's summarize properties and their usage.

* `TransactionalDriver.arjunaDriver` is a prefix of jdbc url which defines
  the Narayana transactional driver is in demand. Data after this prefix is used
  as parameter for later use.

Properties provided at time of connection request defines how to get XADataSource implementation.

* `TransactionalDriver.XADataSource` when used it defines that implementation
  of XADataSource was provided as parameter and will be used for connection withdrawal
* `TransactionalDriver.dynamicClass` defines name of class implementing interface
  `com.arjuna.ats.internal.jdbc.DynamicClass` which is then used for dynamically creating
  of the XADataSource.
* `TransactionalDriver.userName` and `TransactionalDriver.password` you can use if you the particular connection
  needs to be specified with the values. They will be used in call of `XADataSource.getXAConnection(username, password)`.
* `TransactionalDriver.poolConnections` is default as false. The current behavior is simple and does not provide much of pooling
  capabilities. When connection is asked under particular jdbc url then the same is returned everytime. If this property is set to true
  then new connection is returned each time is asked for. Then you need to pass this connection over the application or use
  some pool management strategy on top of the Narayana transactional driver.
