= Narayana saga transactions implementation

The Narayana transaction manager implements saga (http://jbossts.blogspot.co.uk/2017/06/sagas-and-how-they-differ-from-two.html)
transactional pattern naming it as LRA which is abbreviation to Long Running Action.
This saga implementation is supported with creation of specification (https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/0009-LRA)
fitting to schema of Eclipse MicroProfile.

The communication is done over HTTP in way of REST principles.
The Java EE technologies which the LRA builds upon are CDI and JAX-RS.

== Saga - what we are talking about

Saga consists from independent set of operations which all together forms one atomic action.

<<image - flight>>

The operation can be whatever action you think. Here we took take the well known example
of booking a flight and subsequent services. The operations are booking flight, taxi and hotel
and these three forms the atomic action which we want all parts would be processed together.

NOTE: From ACID point of view the Saga transaction relaxes the I (isolation)
and because of that gets availability and is representation of BASE principle (http://queue.acm.org/detail.cfm?id=1394128).

Principle of saga requires existence of a compensations actions invoked in case of failure.
The compensation actions undo work done by the "business" operations. The sequence in case
of the flight example is first to book flight. If that success this change is overly visible
to all the other parties trying to book the flight too (here it's the relaxation of ACID isolation).
Next is the taxi booking, followed by hotel booking. If happens there is no hotel available
in the area for the particular date the whole saga fails and compensation action
for the prior actions are invoked. The responsibility of the compensation action
is undoing what was done - in this case canceling flight and taxi booking. How this is exactly done
depends on the business logic. It could be updating of some database record, call to some API or for example
sending email to the taxi operator.

<<image - flight - cancellation>>

In difference to ACID transaction, where developer makes a sql insertion to database
or sends a message to a broker and the potential undoing such action (rollback) is handled
by the transaction manager in the background, here the responsibility of undoing
is completely moved to the developer who has to implement the compensations callback.

Responsibility of the transaction manager is to gather information about what
operations are part of particular saga (receives participant enlistment) and ensuring
the compensation callback is invoked, even in case of failure (either the participant
or the manager itself).

The LRA implementation also adds way to define a complete callback which
is invoked when saga ends successfully. This could be used for confirmation actions
e.g. customer could be informed with email that order was processed while passing him
details needed for the payment. Or database can be enriched with column informing
if order was successfully processed and SQL statements could be created with that taken into account.

In summary using saga transactions is a design pattern which needs to be
built to the foundation of the application architecture.

== And what about LRA

The LRA is presented by coordinator (or transaction manager) exposing HTTP endpoint for the incoming
remote communication. The coordinator can be placed as separate service but it could
be attached to the application too. The other parties communicate to the coordinator via HTTP
touching the REST endpoints.

For Narayana implementation applies that in case of coordinator packed with the application,
the application itself talks to coordinator with in-memory calls.

Let's take this picture as an example to explain the principles here - we can see there is and LRA
coordinator and 4 services talking to each other in row (still your application can be designed
in different ways).

<<image - services talks each other>>

The client makes a call to the first service. This is the point responsible for letting the LRA
coordinator know about the saga existence. The LRA coordinator in response announces saga identifier
back to the first service. Now the service enlists itself with the created saga
by calling LRA coordinator along with particular saga identifier
and handing over addresses of REST endpoints for compensation (and completion optionally) callbacks.
The LRA coordinator then calls these endpoints reporting that way the saga outcome.
Next the first service takes the saga identifier and adds it as an HTTP header (long-running-action)
to the call of the next service. If the second service distinguishes the LRA header
it can enlists itself (by announcing REST endpoints for compensation/completion callbacks) to LRA coordinator.
All the services are called synchronously in the row. On way back the first service is responsible
for finishing saga (with success) by calling close on the LRA coordinator with the saga identifier.
Meanwhile some of the other services could fail saga by calling cancel on the LRA coordinator,
in which case the close won't succeeds and reports back an error.

If you wan to see this example working check out the Red Hat MSA example (https://github.com/redhat-helloworld-msa/helloworld-msa)
enriched with the LRA capabilities (https://github.com/ochaloup/helloworld-msa/tree/lra).
Detailed installation steps could be found at the page: https://developer.jboss.org/wiki/MSAQuickstartsWithLRAREST-ATOnMinishift

In the next article we will get into CDI annotations used by LRA and their functionality. Meanwhile you can take a look
at the WildFly Swarm microservice implementation from the presented example
https://github.com/ochaloup/hola/blob/lra/src/main/java/com/redhat/developers/msa/hola/HolaResource.java#L81

or in case on other implementations (Spring, Vert.x, Node.js) as well

https://github.com/ochaloup/ola/blob/lra/src/main/java/com/redhat/developers/msa/ola/OlaController.java#L94
https://github.com/ochaloup/aloha/blob/lra/src/main/java/com/redhat/developers/msa/aloha/AlohaVerticle.java#L141
https://github.com/ochaloup/bonjour/blob/lra/lib/api.js#L72


= LRA annotations in details

Welcome back to the series about Narayana saga implementation LRA. See the first part ()
to understand the principles and connection to Eclipse MicroProfile specification (https://github.com/eclipse/microprofile-sandbox/tree/master/proposals/0009-LRA).

If you write your microservice using WildFly Swarm it's nothing easier than use LRA annotations to control the flow of the saga transaction.
