= Manually decoding Solana data
chalda <ondrej.chaloupka@proton.me>
1.0, 2023-05-21

:page-template: post
:page-draft: true
:page-slug: decoding-solana-data
:page-category: solana
:page-tags: Solana, Python
:page-description: A way to manually semi-read Solana transaction and account data
:page-socialImage:  /images/articles/decoding-solana-data/decipher-solana-data.jpg

image::articles/decoding-solana-data/decipher-solana-data.jpg[]

When working with Solana I often need to check what is in the transaction, or in the Solana account.
The reading of data is usually done in some UI that one does not need to do it manually.
While sometimes using UI is not possible or it is not convenient, or one just wants to ensure what the data are really there.
I will share here a way how I do it and on the way we will explore several tools that can be helpful here.

NOTE: As disclaimer I'm not a fried of the hexadecimal format. And there for sure are other ways how to do the task
      I'll be glad to learn, feel free to share with me at link:https://twitter.com/_chalda[@_chalda].

== Solana transaction and account data

Let's talk a bit about the Solana transactions and accounts.
We don't go into details here as there are many other resources
that go deeper in the details. For purpose of this article we want just to define
that Solana defines
link:https://solanacookbook.com/core-concepts/accounts.html#account-model[an account] having
several attributes (like `owner` or possession of `lamports`)
and then the account content is defined as a raw binary data
where the owning program defines the structure.
It's similar with transactions. A transaction has got
defined link:https://medium.com/@asmiller1989/solana-transactions-in-depth-1f7f7fe06ac2[a specific format]
of accounts that participate in the transaction, but the call data
are encoded in format defined by the owning program.

== Solana CLI to fetch data

Let's print some data to investigate on them.

NOTE: I use data of a simple contract program link:https://github.com/ochaloup/simple-admin[`simple-admin].
      It provides a way to create an admin account and when created one can ask to print a message into transaction log.

We use `solana account` command to fetch the data about account.
By default the output shows data in the hexadecimal format. With `--output` we get them in `base64`.

[source,sh]
----
# account DabBrrPf3JcNgKqcYNhn3tVcfPwDpsQ6HdAifNWi1ebJ is an admin account of simple-admin contract
solana -ud account DabBrrPf3JcNgKqcYNhn3tVcfPwDpsQ6HdAifNWi1ebJ --output json
----


[source,json]
.--output json
----
{
  "pubkey": "DabBrrPf3JcNgKqcYNhn3tVcfPwDpsQ6HdAifNWi1ebJ",
  "account": {
    "lamports": 1224960,
    "data": [
      "pZvg+dv0TqnyG8J8NTj5iMEN0Cv0IG7X57+QlCAJzwcIXnvdhqAXFQMAAAAAAAAA",
      "base64"
    ],
    "owner": "sa3HiPEaDZk5JyU1CCmmRbcWnBc9U4TzHq42RWVUNQS",
    "executable": false,
    "rentEpoch": 0
  }
}
----

In the same way we can fetch data about a transaction.
I chose one of the transactions that works with the `simple-admin` contract.
We use `solana confirm` command with `-v` switch to get all data from the transaction,
without the switch only confirmation about the transaction state is displayed.
When we use the `--output json` we get data in `base58` format(**!**).

[source,sh]
----
solana confirm -ud 55E5mPX87Ms55chvKdGUg2XCGrJ1Qp4Pw7ER4z4fCgSqtXQ3JhZGXP7mpohTxPEm8S87Q5PNW7x7MSqx9GDATMiF --output json -v
----

[source,json]
.--output json (shortened)
----
{
  "confirmationStatus": "finalized",
  "transaction": {
    ...
    "message": {
      "header": {
        "numRequiredSignatures": 2,
        "numReadonlySignedAccounts": 1,
        "numReadonlyUnsignedAccounts": 1
      },
      "accountKeys": [
        "CUuLjSEx7q3AB3sRGn3sMJBsSNTmULwowMGUh6NdsxQD",
        "HJ6DPqQhAYRw8YyEuVXV8mwzzNAexxEYVC3aQutWxWn8",
        "DabBrrPf3JcNgKqcYNhn3tVcfPwDpsQ6HdAifNWi1ebJ",
        "sa3HiPEaDZk5JyU1CCmmRbcWnBc9U4TzHq42RWVUNQS"
      ],
      "recentBlockhash": "GJ8fngsibguWjKTAYWeDnqKd4P7mYntDhdEBQpUjyHM6",
      "instructions": [
        {
          "programIdIndex": 3,
          "accounts": [
            2,
            1
          ],
          "data": "7oAbCvAjeJqUZ7RpVyY51x5Sa"
        }
      ]
    }
    ...
  },
}
----

== Converting data to uint8 array

I learnt to check the data content in form of `uint8` binary data array.
Bytes are represented as unsigned integers.
It's the same format as one can see when prints content of the private key file
(like generated one `solana-keyben new --output /tmp/random.keypair; cat /tmp/random.keypair`).

I use simple python scripts that converts data from here and there.
It can be found at my gist here:
link:https://gist.github.com/ochaloup/58ceee3ed436766ba7c444bf3fbc8545[tobase58.py],
link:https://gist.github.com/ochaloup/8ecfd13ea84d4ac8603569716b1b34fb[frombase58.py],
link: https://gist.github.com/ochaloup/e942f43e6c8a1356f422a1703596bad2[tobase64.py],
link:https://gist.github.com/ochaloup/b3c2c2410f63782b75abcda96d261fea[frombase64.py].
And scripts to do some handling of that data:
link:https://gist.github.com/ochaloup/4d6ca93a6826a65c3f1f781d5af59d4b[arraybyindex.sh],
link:https://gist.github.com/ochaloup/87d8745c0aa7797fe1e9dbdfdb01c931[toout.py].

++++
<table>
  <tr>
    <td>
    <script src="https://gist.github.com/ochaloup/58ceee3ed436766ba7c444bf3fbc8545.js"></script>
    </td>
    <td>
    <script src="https://gist.github.com/ochaloup/8ecfd13ea84d4ac8603569716b1b34fb.js"></script>
    </td>
    <td>
    <script src="https://gist.github.com/ochaloup/e942f43e6c8a1356f422a1703596bad2.js"></script>
    </td>
    <td>
    <script src="https://gist.github.com/ochaloup/b3c2c2410f63782b75abcda96d261fea.js"></script>
    </td>
  </tr>
  <tr>
    <td>
    <script src="https://gist.github.com/ochaloup/4d6ca93a6826a65c3f1f781d5af59d4b.js"></script>
    </td>
    <td>
    <script src="https://gist.github.com/ochaloup/87d8745c0aa7797fe1e9dbdfdb01c931.js"></script>
    </td>
  </tr>
</table>
++++

[NOTE]
====
Instead of argument `solana ccount--output` we can use `--output-file /path/to/file`
that makes the account data to be saved in a file in the binary form.
One way to work with them is to use bash `od` command like this:

[source,sh]
----
# loading data from binary format as u8 array
decimal_array=($(od -An -t u1 < '/path/to/file'))
# printing data
echo "${decimal_array[@]}"

# printing only last 32 bytes of the loaded data
echo "${decimal_array[@]:(-32):32}"
----

====

== Data interpretation

We started with the simple Solana program contract written with https://www.anchor-lang.com[Anchor].
When the program is written with Anchor we have a benefit that we know that data is encoded
with https://borsh.io[borsh] and that Anchor uses `8 bytes`
https://docs.rs/anchor-lang/latest/anchor_lang/trait.Discriminator.html[discriminator]
(`sha256` hash of the account's Rust identifier).

We have the https://github.com/ochaloup/simple-admin/[contract source code]
at the hand.
The data structure of the
https://github.com/ochaloup/simple-admin/blob/blog-post/programs/simple-admin/src/state/simple_account.rs[`simple_account`]
is declaratively defined in the code. We can see there is `Pubkey`
that https://docs.rs/solana-program/latest/solana_program/pubkey/struct.Pubkey.html[Solana uses of length 32 bytes]
and then a `u64` number that has got length of 8 bytes.

[source,rust]
----
pub struct SimpleAccount {
    pub admin: Pubkey,
    pub print_call_count: u64,
}
----

With call of `solana account` CLI command we've got `base64` formatted data. Let's decode it to uint array
with the use of the scripts above.

[source,sh]
----
solana -ud account DabBrrPf3JcNgKqcYNhn3tVcfPwDpsQ6HdAifNWi1ebJ --output json
# ... taking data base64 string ...

frombase64.py pZvg+dv0TqnyG8J8NTj5iMEN0Cv0IG7X57+QlCAJzwcIXnvdhqAXFQMAAAAAAAAA
> [165,155,224,249,219,244,78,169,242,27,194,124,53,56,249,136,193,13,208,43,244,32,110,215,231,191,144,148,32,9,207,7,8,94,123,221,134,160,23,21,3,0,0,0,0,0,0,0]
----

We can see the array consists of 48 bytes. The first 8 bytes is the descriptor of Anchor,
the next 32 bytes is the `Pubkey` and last 8 bytes is the number
(it's the uint and Solana uses Little Endian encoding).

[source,sh]
----
# reading bytes at index 8 (9th byte) in length of 32 bytes
arraybyindex.sh [165,155,224,249,219,244,78,169,242,27,194,124,53,56,249,136,193,13,208,43,244,32,110,215,231,191,144,148,32,9,207,7,8,94,123,221,134,160,23,21,3,0,0,0,0,0,0,0] 8 32
# > [242,27,194,124,53,56,249,136,193,13,208,43,244,32,110,215,231,191,144,148,32,9,207,7,8,94,123,221,134,160,23,21]
# printing the 32 bytes in base58 format (Pubkey)
tobase58.py [242,27,194,124,53,56,249,136,193,13,208,43,244,32,110,215,231,191,144,148,32,9,207,7,8,94,123,221,134,160,23,21]
HJ6DPqQhAYRw8YyEuVXV8mwzzNAexxEYVC3aQutWxWn8

# reading bytes at index 40 (41st byte) in length of 8 bytes
arraybyindex.sh [165,155,224,249,219,244,78,169,242,27,194,124,53,56,249,136,193,13,208,43,244,32,110,215,231,191,144,148,32,9,207,7,8,94,123,221,134,160,23,21,3,0,0,0,0,0,0,0] 40 8
# > [3,0,0,0,0,0,0,0]
# printing the 8 bytes as integer
toout.py [3,0,0,0,0,0,0,0] int
# > 3
----

Until now we omitted the first 8 bytes which is the Anchor discriminator (i.e., `[165,155,224,249,219,244,78,169]`).
It's https://solana.stackexchange.com/a/5998/1386[a hash of account name] and we can consider it as internal Anchor details.
But if we want to double-check that we work with the right account - as the Anchor uses the discriminator to ensure
the loaded data belongs to the right account - then when having the source code we can get expanded version of the sources
when using `expand` CLI arguments.

[source,sh]
----
git clone https://github.com/ochaloup/simple-admin.git -b blog-post

anchor expand
# ...
# > Expanded simple-admin into file .anchor/expanded-macros/simple-admin/simple-admin-0.1.0.rs

cat .anchor/expanded-macros/simple-admin/simple-admin-0.1.0.rs | grep -i Discriminator
# ...
# > impl anchor_lang::Discriminator for SimpleAccount {
# >     const DISCRIMINATOR: [u8; 8] = [165, 155, 224, 249, 219, 244, 78, 169];
----

=== Looking at non-Anchor program accounts

As there are no prescriptions in the data format in the accounts
it's not only the borsh one that encodes data. The other strategy that one can met for Solana accounts
to encode the binary data is link:https://docs.rs/bincode/latest/bincode/[bincode].
It's used often in Solana program library.
An example could be the
https://github.com/solana-labs/solana/blob/v1.14.17/runtime/src/inline_spl_token.rs#LL11C16-L11C30[SPL Token program].
Let's do quick check here. We create a new mint and mint a token to ATA wallet address that we examine.

[source,sh]
----
# creating a new mint of the token (-ud signifies we work on devnet)
spl-token -ud create-token --decimals 0
# > Creating token FqQXsU826gjPFXkgYXpVyuaDkgVbmvULz2MktNm1p7n6 under program TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA
# > Address:  FqQXsU826gjPFXkgYXpVyuaDkgVbmvULz2MktNm1p7n6
# > Decimals:  0

# creating token ATA account of the wallet (~/.config/solana/id.json)
spl-token -ud create-account FqQXsU826gjPFXkgYXpVyuaDkgVbmvULz2MktNm1p7n6

# mint 100 tokens to wallet ATA address
spl-token -ud mint FqQXsU826gjPFXkgYXpVyuaDkgVbmvULz2MktNm1p7n6 100
# > Minting 100 tokens
# >   Token: FqQXsU826gjPFXkgYXpVyuaDkgVbmvULz2MktNm1p7n6
# >   Recipient: JCX5iiNKRhkSVsqjspSgJxT5KmJ7Pqfoqr2Gt5snz8sP

solana account -ud JCX5iiNKRhkSVsqjspSgJxT5KmJ7Pqfoqr2Gt5snz8sP --output json
# > Output below:
----

[source,json]
----
{
  "pubkey": "JCX5iiNKRhkSVsqjspSgJxT5KmJ7Pqfoqr2Gt5snz8sP",
  "account": {
    "lamports": 2039280,
    "data": [
      "3GoaknTR+oDWqFG297b0/v2Vu8SDp7+L82vTdUdUB6eqlmtWff4bdZUd8oayhnUR5sMO/i+gRTg93gti4R0UbmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
      "base64"
    ],
    "owner": "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",
    "executable": false,
    "rentEpoch": 0
  }
}
----

Now we can convert data to `uint`` array and check if the data length
(https://github.com/solana-labs/solana/blob/v1.14.17/runtime/src/inline_spl_token.rs#L24[that should be 165])
matches.

[source,sh]
----
ARR=`frombase64.py '3GoaknTR+oDWqFG297b0/v2Vu8SDp7+L82vTdUdUB6eqlmtWff4bdZUd8oayhnUR5sMO/i+gRTg93gti4R0UbmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'`
echo $ARR
# > [220,106,26,146,116,209,250,128,214,168,81,182,247,182,244,254,253,149,187,196,131,167,191,139,243,107,211,117,71,84,7,167,170,150,107,86,125,254,27,117,149,29,242,134,178,134,117,17,230,195,14,254,47,160,69,56,61,222,11,98,225,29,20,110,100,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]

echo "$ARR" | sed 's/[^,]//g' | wc -c
# > 165
----

Token program does not use any discriminator for checking the account type and we can see
that the first data belongs to public key of
https://github.com/solana-labs/solana/blob/v1.14.17/runtime/src/inline_spl_token.rs#L11-L13[the mint and the owner of the token].

[source,sh]
----
arraybyindex.sh $ARR 0 32
# > [220,106,26,146,116,209,250,128,214,168,81,182,247,182,244,254,253,149,187,196,131,167,191,139,243,107,211,117,71,84,7,167]
tobase58.py '[220,106,26,146,116,209,250,128,214,168,81,182,247,182,244,254,253,149,187,196,131,167,191,139,243,107,211,117,71,84,7,167]'
# > FqQXsU826gjPFXkgYXpVyuaDkgVbmvULz2MktNm1p7n6
arraybyindex.sh $ARR 32 32
# > [170,150,107,86,125,254,27,117,149,29,242,134,178,134,117,17,230,195,14,254,47,160,69,56,61,222,11,98,225,29,20,110]
tobase58.py '[170,150,107,86,125,254,27,117,149,29,242,134,178,134,117,17,230,195,14,254,47,160,69,56,61,222,11,98,225,29,20,110]'
# > CUuLjSEx7q3AB3sRGn3sMJBsSNTmULwowMGUh6NdsxQ
----

=== From bincode to borsh

Native Solana programs often use `bincode` library (within `serde`) to get the data coded.
The `borsh` and `bincode` base64 data formats are not fully compatible but they could be transfered.
Recently I started https://github.com/coral-xyz/anchor/pull/2486#issuecomment-1549469516[a discussion at Anchor project]
where the maintainer `acheroncrypto` managed the coding
https://github.com/coral-xyz/anchor/pull/2486/commits/b99beceb52e5b814dbc8953146b074fbe1b57b82#diff-c1f8f7498da827a634bddc8a7559198bc99b296e9d9e8b91a70b503662995b8cR2248[from bincode to borsh base64 format].

===

The similar approach can be used when one search for a filter format to print data of program accounts (using Solana RPC HTTP call
https://docs.solana.com/api/http#getprogramaccounts[getProgramAccounts]).
See details in my answer about looking through
https://solana.stackexchange.com/questions/5677/deployed-contracts-from-a-user-address/5691#5691[the Solana bpf_loader_upgradeable data structures].



=== Data of transaction

// TODO:


The data of the Solana accounts and the data part of the Solana transaction are just binary data that the particular program defines the structure of the data. It can be arbitrary.
For Anchor program, at least, there are some basic expectations we can consider
(like first 8 bytes are the discriminator and data is encoded by borsh).




https://bettercallsol.dev/ -> https://blog.labeleven.dev/solana-transactions-with-better-call-sol
https://borsh.m2.xyz/address/5CYBeckoJMrJ9pg1qXi3vcn2CxrYTgQ7KVt1nysWTMMV
https://anchor.so/tx/inspector
https://solana.fm/address/8szGkuLTAux9XMgZ2vtY39jVSowEcpBfFfD8hXSEqdGC/anchor-account?cluster=devnet-solana&mode=pro
https://solana.fm/tx/55E5mPX87Ms55chvKdGUg2XCGrJ1Qp4Pw7ER4z4fCgSqtXQ3JhZGXP7mpohTxPEm8S87Q5PNW7x7MSqx9GDATMiF?cluster=devnet-solana&mode=pro
